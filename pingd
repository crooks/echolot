#!/usr/bin/perl -wT

# (c) 2002 Peter Palfrader <peter@palfrader.org>
# $Id: pingd,v 1.5 2002/06/20 04:30:04 weasel Exp $
#

=pod

=head1 NAME

pingd - echolot ping daemon

=head1 SYNOPSIS

=over

=item B<pingd> B<start>

=item B<pingd> B<stop>

=item B<pingd> B<add> I<address>

=back

=head1 DESCRIPTION

pingd is a the heart of echolot. Echolot is a pinger for anonymous remailers. 

A Pinger in the context of anonymous remailers is a program that regularily
sends messages through remailers to check their reliability. It then calculates
reliability statistics which are used by remailer clients to choose the chain
of remailers to use.

Additionally it collects configuration parameters and keys of all remailers and
offers them in a format readable by remailer clients. 

When called without parameters pingd schedules tasks like sending pings,
processing incoming mail and requesting remailer-xxx data and runs them in
configurable intervalls.

=head1 COMMANDS

=over

=item B<start>

Start the ping daemon.

=item B<stop>

Send the running pingd process a SIGTERM.

=item B<add> I<address>

Add I<address> to the list of remailers to query for
keys and confs.

=head1 OPTIONS

none

=back

=head1 FILES

F<pingd.conf>

=head1 AUTHOR

Peter Palfrader E<lt>pp@3node.com<gt>

=head1 SEE ALSO

echolot Documentation

=head1 BUGS

Please report them at <lt>URL:http://savannah.gnu.org/bugs/?group=echolot<gt>

=cut

use strict;
use XML::Parser;
use XML::Dumper;
use Getopt::Long;
use English;
use lib qw{ . lib };
use Echolot::Config;
use Echolot::Globals;
use Echolot::Storage::File;
use Echolot::Scheduler;
use Echolot::Conf;
use Echolot::Mailin;
use Echolot::Pinger;
use Echolot::Stats;
use Echolot::Commands;

$ENV{'PATH'} = '/bin:/usr/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};


my $scheduler;

sub setSigHandlers() {
	$SIG{'HUP'} = sub {
		print "Got SIGINT. scheduling readcommands\n";
		$scheduler->schedule('readcommands', time() );
	};
	$SIG{'INT'} = sub {
		print "Got SIGINT. scheduling exit\n";
		$scheduler->schedule('exit', time() );
	};
	$SIG{'QUIT'} = sub {
		print "Got SIGQUIT. scheduling exit\n";
		$scheduler->schedule('exit', time() );
	};
	$SIG{'TERM'} = sub {
		print "Got SIGTERM. scheduling exit\n";
		$scheduler->schedule('exit', time() );
	};
};

sub commit_prospective_address() {
	Echolot::Globals::get()->{'storage'}->commit_prospective_address();
};




#Echolot::Mailin::process();
#Echolot::Pinger::send_pings();
#Echolot::Mailin::process();
#Echolot::Conf::send_requests();
#Echolot::Stats::build();



my $params;
Getopt::Long::config('bundling');
if (!GetOptions (
	'help'    =>  \$params->{'help'},
	'verbose' =>  \$params->{'verbose'}
	)) {
	die ("$PROGRAM_NAME: Usage: $PROGRAM_NAME [-fwhv]\n");
};
if ($params->{'help'}) {
    print ("Usage: $PROGRAM_NAME [options]\n"); #FIXME
    exit 0;
};

my $COMMAND = shift @ARGV;
die ("command required\n") unless defined $COMMAND;


Echolot::Config::init();
chdir( Echolot::Config::get()->{'homedir'} );
Echolot::Globals::init();


if ($COMMAND eq 'add') {
	my $address = shift @ARGV;
	die ("add requires argument <address>\n") unless defined $address;
	die ("argument <address> is not a valid email address\n") unless ($address =~ /^[a-zA-Z0-9+.-]+\@[a-zA-Z0-9+.-]+$/ );
	Echolot::Commands::addCommand("add $address");
	# FIXME send hup
} elsif ($COMMAND eq 'stop') {
	die ("stop not implemented yet");
} elsif ($COMMAND eq 'start') {
	setSigHandlers();
	Echolot::Globals::initStorage();

	$scheduler = new Echolot::Scheduler;
	$scheduler->add('exit'               ,      -1                                      , 0, 'exit' );
	$scheduler->add('readcommands'        ,     -1                                      , 0, \&Echolot::Commands::processCommands );

	$scheduler->add('processmail'         ,     60                                      , 0, \&Echolot::Mailin::process );
	$scheduler->add('ping'                ,  Echolot::Config::get()->{'pinger_interval'}, 0, \&Echolot::Pinger::send_pings );
	$scheduler->add('buildstats'          ,     60                                      , 0, \&Echolot::Stats::build );

	$scheduler->add('commitprospectives'  ,   30*60                                     ,240, \&commit_prospective_address );
	$scheduler->add('getkeyconf'          ,   60*60                                     , 0, \&Echolot::Conf::send_requests );

	$scheduler->run();

	Echolot::Globals::get()->{'storage'}->commit();
	Echolot::Globals::get()->{'storage'}->finish();
} else {
	die ("Command $COMMAND unknown");
};

exit 0;

# vim: set ts=4 shiftwidth=4:
