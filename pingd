#!/usr/bin/perl -w

$| = 1;

# (c) 2002 Peter Palfrader <peter@palfrader.org>
# $Id: pingd,v 1.68 2002/08/21 19:46:04 weasel Exp $
#

=pod

=head1 NAME

pingd - echolot ping daemon

=head1 SYNOPSIS

=over

=item B<pingd> B<start>

=item B<pingd> B<stop>

=item B<pingd> B<process>

=item B<pingd> B<add> I<address> [I<address> ...]

=item B<pingd> B<delete> I<address> [I<address> ...]

=item B<pingd> B<set> option=value [option=value..] I<address> [I<address> ...]

=item B<pingd> B<setremailercaps> I<capsstring>

=item B<pingd> B<deleteremailercaps> I<address>

=item B<pingd> B<getkeyconf> [I<address> [I<address> ...]]

=item B<pingd> B<buildstats>

=item B<pingd> B<buildkeys>

=item B<pingd> B<buildthesaurus>

=item B<pingd> B<dumpconf>

=back

=head1 DESCRIPTION

pingd is a the heart of echolot. Echolot is a pinger for anonymous remailers. 

A Pinger in the context of anonymous remailers is a program that regularily
sends messages through remailers to check their reliability. It then calculates
reliability statistics which are used by remailer clients to choose the chain
of remailers to use.

Additionally it collects configuration parameters and keys of all remailers and
offers them in a format readable by remailer clients. 

When called without parameters pingd schedules tasks like sending pings,
processing incoming mail and requesting remailer-xxx data and runs them in
configurable intervalls.

=head1 COMMANDS

=over

=item B<start>

Start the ping daemon.

=item B<stop>

Send the running pingd process a SIGTERM.

=item B<process>

Sends a HUP signal to the daemon which instructs it to process the commands.

For other affects of sending the HUP Signal see the SIGNALS section below.

=item B<add> I<address> [I<address> ...]

Add I<address> to the list of remailers to query for
keys and confs.

=item B<delete> I<address> [I<address> ...]

Delete I<address> from the list of remailers to query for
keys and confs. Delete all statistics and keys for that remailer.

=item B<set> option=value [option=value..] I<address> [I<address> ...]

Possible options and values:

=over

=item B<showit=>{B<on>,B<off>}

Set B<showit> (show remailer in mlist, rlist etc.) for remailer I<address> to
either B<on> or B<off>.

=item B<pingit=>{B<on>,B<off>}

Set B<pingit> (send out pings to that remailer) for remailer I<address> to
either B<on> or B<off>.

=item B<fetch=>{B<on>,B<off>}

Set B<fetch> (fetch remailer-key and remailer-conf) for remailer I<address> to
either B<on> or B<off>.

=back

=item B<setremailercaps> I<capsstring>

Some remailers (Mixmaster V2 - currently lcs and passthru2) don't return a
useable remailer-conf message. For such remailers you need to set it manually.

For instance:

    ./pingd setremailercaps '$remailer{"passthru2"} = "<mixer@immd1.informatik.uni-erlangen.de> mix middle";'
    ./pingd setremailercaps '$remailer{"lcs"} = "<mix@anon.lcs.mit.edu> mix klen1000";'

=item B<deleteremailercaps> I<address>

Delete remailer-conf data for I<address>. The config data will be reset from
the next valid remailer-conf reply by the remailer.

=item B<getkeyconf> [I<address> [I<address> ...]]

Send a command to immediatly request keys and configuration from remailers.
If no addresses are given, then requests will be sent to all remailers.

=item B<buildstats>

Send a command to immediatly rebuild stats.

=item B<buildkeys>

Send a command to immediatly rebuild the keyrings.

=item B<buildthesaurus>

Send a command to immediatly rebuild the Thesaurus.

=item B<dumpconf>

Dumps the current configuration to standard output.

=back

=head1 OPTIONS

=over

=item B<--basedir>

The home directory to which everything else is relative to. See the BASE
DIRECTORY section below.

=item B<--verbose>

Verbose mode. Causes B<pingd> to print debugging messages about its progress.

=item B<--quiet>

Quiet mode. Be even more quient than normally.

=item B<--help>

Print a short help and exit sucessfully.

=item B<--version>

Print version number and exit sucessfully.

=item B<--nohup>

Usefull only with the B<add>, B<set>, B<setremailercaps>,
B<deleteremailercaps>, B<getkeyconf>, B<buildstats>, B<buildkeys>,
or B<buildthesaurus> command.

Don't send a HUP signal to the daemon which instructs it to process the
commands after adding the command to the task list.

Per default such a signal is sent.

=item B<--process>

Usefull only with the B<start> command.

Read and process the commands file on startup.

=item B<--detach>

Usefull only with the B<start> command.

Tell B<pingd> to detach.

=back

=head1 BASE DIRECTORY

The home directory to which everything else is relative to.

Basedir defaults to whatever directory the B<pingd> binary is located. It can
get overridden by the B<ECHOLOT_HOME> environment variable which in turn is
weaker than the B<--basedir> setting.

This directory is then used to locate the configuration file B<pingd.conf> (see
FILES below).

The B<homedir> setting in B<pingd.conf> finally sets the base directory.

=head1 FILES

The configuration file is searched in those places in that order:

=over   

=item the file pointed to by the B<ECHOLOT_CONF> environment variable

=item <basedir>/pingd.conf

=item $HOME/echolot/pingd.conf

=item $HOME/pingd.conf

=item $HOME/.pingd.conf

=item /etc/echolot/pingd.conf

=item /etc/pingd.conf

=back

=head1 ENVIRONMENT

=over

=item ECHOLOT_CONF echolot config file (see section FILES)

=item ECHOLOT_HOME echolot base directory (see section BASE DIRECTORY)

=back

=head1 SIGNALS

On B<SIGINT>, B<SIGQUIT>, and B<SIGTERM> B<pingd> will schedule a shutdown
for as soon as the current actions are finished or immediatly if no actions are
currently beeing processed. It will then write all metadata and pingdata to
disk and close all files cleanly before exiting.

On B<SIGHUP> <pingd> will execute any pending commands from the commands file
(B<commands.txt> per default).  It also closes and reopens the file 'output'
which is used for stdout and stderr in case the daemon was told to detach.
This can be used if you want to rotate that file.

=head1 AUTHOR

Peter Palfrader E<lt>peter@palfrader.orgE<gt>

=head1 BUGS

Please report them at E<lt>URL:http://savannah.gnu.org/bugs/?group=echolotE<gt>

=cut

use strict;
use FindBin qw{ $Bin };
use lib ( $Bin, "$Bin/lib" );
use Getopt::Long;
use English;
use Carp;
use Echolot::Config;
use Echolot::Globals;
use Echolot::Storage::File;
use Echolot::Scheduler;
use Echolot::Conf;
use Echolot::Mailin;
use Echolot::Pinger;
use Echolot::Stats;
use Echolot::Commands;
use Echolot::Thesaurus;
use POSIX qw(setsid);

delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};


my $VERSION = '2.0beta31';


my $redirected_stdio = 0;

sub setSigHandlers() {
	$SIG{'HUP'} = sub {
		print "Got SIGHUP. scheduling readcommands\n";
		Echolot::Globals::get()->{'scheduler'}->schedule('readcommands', time() );
		if ($redirected_stdio) {
			close STDOUT;
			close STDERR;
			open (STDOUT, ">>output") or die ("Cannot open 'output' as STDOUT\n");
			open (STDERR, ">&STDOUT") or die ("Cannot dup STDOUT as STDERR\n");
		};
	};
	$SIG{'INT'} = sub {
		print "Got SIGINT. scheduling exit\n";
		Echolot::Globals::get()->{'scheduler'}->schedule('exit', time() );
	};
	$SIG{'QUIT'} = sub {
		print "Got SIGQUIT. scheduling exit\n";
		Echolot::Globals::get()->{'scheduler'}->schedule('exit', time() );
	};
	$SIG{'TERM'} = sub {
		print "Got SIGTERM. scheduling exit\n";
		Echolot::Globals::get()->{'scheduler'}->schedule('exit', time() );
	};
};



sub commit_prospective_address() {
	Echolot::Globals::get()->{'storage'}->commit_prospective_address();
};
sub expire() {
	Echolot::Globals::get()->{'storage'}->expire();
};





sub command_adddelete(@) {
	my $command = shift @_;
	my @argv = @_;

	die ("command_adddelete requires command\n") unless defined $command;
	die ("add requires argument <address>\n") unless scalar @argv;
	my @addresses;
	for my $address (@argv) {
		die ("argument <address> is not a valid email address\n") unless ($address =~ /^[a-zA-Z0-9+._-]+\@[a-zA-Z0-9+.-]+$/ );
		push @addresses, $address;
	};
	for my $address (@addresses) {
		Echolot::Commands::addCommand("$command $address");
	};
};

sub command_set(@) {
	my @argv = @_;

	my @settings;
	while (scalar @argv && $argv[0] =~ /^(showit|pingit|fetch)=(on|off)$/) {
		push @settings, $argv[0];
		shift @argv;
	};

	my @addresses;
	for my $address (@argv) {
		die ("argument $address is not a valid email address\n") unless ($address =~ /^[a-zA-Z0-9+._-]+\@[a-zA-Z0-9+.-]+$/ );
		push @addresses, $address;
	};

	for my $address (@argv) {
		for my $setting (@settings) {
			Echolot::Commands::addCommand("set $address $setting");
		};
	};
};

sub command_setremailercaps(@) {
	my @argv = @_;

	my @caps;
	for my $caps (@argv) {
		my ($remailer_nick, $remailer_address) = ($caps =~ /^\s*  \$remailer{"(.*)"}  \s*=\s*  "<(.*@.*)>.*";   \s*$/ix);
		die ("caps '$caps' is not a valid remailer caps line\n") unless (defined $remailer_nick && defined $remailer_address);
		push @caps, {
			address => $remailer_address,
			caps => $caps };
	};
	for my $caps (@caps) {
		Echolot::Commands::addCommand("setremailercaps ".$caps->{'address'}." ".$caps->{'caps'});
	};
};

sub command_deleteremailercaps(@) {
	my @argv = @_;

	my @addresses;
	for my $address (@argv) {
		die ("argument $address is not a valid email address\n") unless ($address =~ /^[a-zA-Z0-9+._-]+\@[a-zA-Z0-9+.-]+$/ );
		push @addresses, $address;
	};

	for my $address (@addresses) {
		Echolot::Commands::addCommand("deleteremailercaps $address");
	};
};

sub command_getkeyconf(@) {
	my @argv = @_;

	my @addresses;
	for my $address (@argv) {
		die ("argument $address is not a valid email address\n") unless ($address =~ /^[a-zA-Z0-9+._-]+\@[a-zA-Z0-9+.-]+$/ );
		push @addresses, $address;
	};

	push @addresses, 'all' unless (scalar @addresses);

	for my $address (@addresses) {
		Echolot::Commands::addCommand("getkeyconf $address");
	};
};


sub pid_exists() {
	return (-e Echolot::Config::get()->{'pidfile'});
};

sub daemon_run($) {
	my ($process) = @_;

	die ("Pidfile '".Echolot::Config::get()->{'pidfile'}."' exists\n")
		if pid_exists();
	open (PIDFILE, '>'.Echolot::Config::get()->{'pidfile'}) or
		confess ("Cannot open pidfile '".Echolot::Config::get()->{'pidfile'}."': $!\n");
	print PIDFILE "$PROCESS_ID ".Echolot::Globals::get()->{'hostname'}." ".time()."\n";
	close PIDFILE;

	Echolot::Globals::initStorage();
	setSigHandlers();

	Echolot::Globals::get()->{'scheduler'} = new Echolot::Scheduler;
	my $scheduler = Echolot::Globals::get()->{'scheduler'};
	$scheduler->add('exit'                ,     -1                                         , 0, 'exit' );
	$scheduler->add('readcommands'        ,     -1                                         , 0, \&Echolot::Commands::processCommands );

	$scheduler->add('processmail'         , Echolot::Config::get()->{'processmail'}        , 0, \&Echolot::Mailin::process );
	$scheduler->add('ping'                , Echolot::Config::get()->{'pinger_interval'}    , 0, \&Echolot::Pinger::send_pings );
	$scheduler->add('buildstats'          , Echolot::Config::get()->{'buildstats'}         , 0, \&Echolot::Stats::build_stats );
	$scheduler->add('buildkeys'           , Echolot::Config::get()->{'buildkeys'}          , 0, \&Echolot::Stats::build_keys );
	$scheduler->add('buildthesaurus'      , Echolot::Config::get()->{'buildthesaurus'}     , 0, \&Echolot::Thesaurus::build_thesaurus );

	$scheduler->add('commitprospectives'  , Echolot::Config::get()->{'commitprospectives'} , 0, \&commit_prospective_address );
	$scheduler->add('expire'              , Echolot::Config::get()->{'expire'}             , 0, \&expire );
	$scheduler->add('getkeyconf'          , Echolot::Config::get()->{'getkeyconf_interval'}, 0, \&Echolot::Conf::send_requests );
	$scheduler->add('check_resurrection'  , Echolot::Config::get()->{'check_resurrection'} , 0, \&Echolot::Conf::check_resurrection );

	Echolot::Globals::get()->{'scheduler'}->schedule('readcommands', time() )
		if ($process);

	$scheduler->run();

	Echolot::Globals::get()->{'storage'}->commit();
	Echolot::Globals::get()->{'storage'}->finish();

	unlink (Echolot::Config::get()->{'pidfile'}) or
		cluck ("Cannot unlink pidfile ".Echolot::Config::get()->{'pidfile'});
};

sub send_sig($) {
	my ($sig) = @_;

	die ("Pidfile '".Echolot::Config::get()->{'pidfile'}."' does not exist\n")
		unless pid_exists();
	open (PIDFILE, '<'.Echolot::Config::get()->{'pidfile'}) or
		confess ("Cannot open pidfile '".Echolot::Config::get()->{'pidfile'}."': $!\n");
	my $line = <PIDFILE>;
	close PIDFILE;

	my ($pid, $host, $time) = $line =~ /^(\d+) \s+ (\S+) \s+ (\d+) \s* $/x or
		confess ("Cannot parse pidfile '$line'\n");
	my $sent = kill $sig, $pid;
	($sent == 1) or
		confess ("Did not send signal $sig to exactly one process but $sent. (pidfile reads $line)\n");
};

sub daemon_hup() {
	send_sig(1);
};

sub daemon_stop() {
	send_sig(15);
};

sub make_dirs() {
	for my $dir (
		Echolot::Config::get()->{'resultdir'},
		Echolot::Config::get()->{'thesaurusdir'},
	) {
		if ( ! -d $dir ) {
			mkdir ($dir, 0755) or
				confess ("Cannot create directory $dir: $!\n");
		};
	};
	my @dirs = (
		Echolot::Config::get()->{'private_resultdir'},
		Echolot::Config::get()->{'gnupghome'},
		Echolot::Config::get()->{'mixhome'},
		Echolot::Config::get()->{'tmpdir'},
		Echolot::Config::get()->{'storage'}->{'File'}->{'basedir'},
		Echolot::Config::get()->{'mailerrordir'},
		Echolot::Config::get()->{'mailerrordir'}.'/cur',
		Echolot::Config::get()->{'mailerrordir'}.'/tmp',
		Echolot::Config::get()->{'mailerrordir'}.'/new');
	push @dirs, (
		Echolot::Config::get()->{'mailin'}.'/cur',
		Echolot::Config::get()->{'mailin'}.'/tmp',
		Echolot::Config::get()->{'mailin'}.'/new' )
		if (-d Echolot::Config::get()->{'mailin'});
		
	for my $dir (@dirs) {
		if ( ! -d $dir ) {
			mkdir ($dir, 0700) or
				confess ("Cannot create directory $dir: $!\n");
		};
	};
};

sub hup_if_wanted($) {
	my ($nohup) = @_;
	if (!$nohup && pid_exists()) {
		daemon_hup()
	} else {
		print "Don't forget to run $PROGRAM_NAME process.\n";
	};
};










my $params = { basedir => $Bin };
$params->{'basedir'} = $ENV{'ECHOLOT_HOME'} if (defined $ENV{'ECHOLOT_HOME'});

Getopt::Long::config('bundling');
if (!GetOptions (
	'help'     =>  \$params->{'help'},
	'version'  =>  \$params->{'version'},
	'verbose+' =>  \$params->{'verbose'},
	'nohup'    =>  \$params->{'nohup'},
	'detach'   =>  \$params->{'detach'},
	'process'  =>  \$params->{'process'},
	'basedir'  =>  \$params->{'basedir'},
	'quiet'    =>  \$params->{'quiet'},
	)) {
	die ("$PROGRAM_NAME: Usage: $PROGRAM_NAME [-fwhv]\n");
};
if ($params->{'help'}) {
    print ("Usage: $PROGRAM_NAME [options] command\n");
    print ("See man pingd or perldoc pingd for more info.\n");
    print ("echolot $VERSION - (c) 2002 Peter Palfrader <peter\@palfrader.org>\n");
    print ("http://savannah.gnu.org/projects/echolot/\n");
	print ("\n");
	print ("Commands:\n");
	print ("  start      starts echolot pingd\n");
	print ("             signals pingd to ... \n");
	print ("  stop               ... shutdown\n");
	print ("  process            ... reopen outfile and process commands\n");
	print ("  add                ... add a remailer address\n");
	print ("  delete             ... delete a remailer address\n");
	print ("  set                ... set remailer options\n");
	print ("  setremailercaps    ... set remailer capabilities manually\n");
	print ("  deleteremailercaps ... delete remailer capabilities manually\n");
	print ("  getkeyconf         ... request remailer-xxx data immediatly\n");
	print ("  buildstats         ... build remailer stats immediatly\n");
	print ("  buildkeys          ... buid keyrings immediatly\n");
	print ("  buildthesaurus     ... build thesaurus immediatly\n");
	print ("  dumpconf   dump configuration\n");
    exit 0;
};
if ($params->{'version'}) {
    print ("echolot $VERSION\n");
    print ("(c) 2002 Peter Palfrader <peter\@palfrader.org>\n");
    print ("http://savannah.gnu.org/projects/echolot/\n");
    exit 0;
};
$params->{'quiet'} = undef if ($params->{'verbose'});

my $COMMAND = shift @ARGV;
die ("command required\n") unless defined $COMMAND;


Echolot::Config::init( $params );
chdir( Echolot::Config::get()->{'homedir'} );
Echolot::Globals::init( version => $VERSION);


if ($COMMAND eq 'add' || $COMMAND eq 'delete') {
	command_adddelete($COMMAND, @ARGV);
	hup_if_wanted($params->{'nohup'});
} elsif ($COMMAND eq 'set') {
	command_set(@ARGV);
	hup_if_wanted($params->{'nohup'});
} elsif ($COMMAND eq 'deleteremailercaps') {
	command_deleteremailercaps(@ARGV);
	hup_if_wanted($params->{'nohup'});
} elsif ($COMMAND eq 'setremailercaps') {
	command_setremailercaps(@ARGV);
	hup_if_wanted($params->{'nohup'});
} elsif ($COMMAND eq 'getkeyconf') {
	command_getkeyconf(@ARGV);
	hup_if_wanted($params->{'nohup'});
} elsif ($COMMAND eq 'buildstats') {
	Echolot::Commands::addCommand("buildstats");
	hup_if_wanted($params->{'nohup'});
} elsif ($COMMAND eq 'buildkeys') {
	Echolot::Commands::addCommand("buildkeys");
	hup_if_wanted($params->{'nohup'});
} elsif ($COMMAND eq 'buildthesaurus') {
	Echolot::Commands::addCommand("buildthesaurus");
	hup_if_wanted($params->{'nohup'});
} elsif ($COMMAND eq 'process') {
	daemon_hup();
} elsif ($COMMAND eq 'stop') {
	daemon_stop();
} elsif ($COMMAND eq 'start') {
	die ("Pidfile '".Echolot::Config::get()->{'pidfile'}."' exists\n")
		if pid_exists();
	make_dirs();
	if ($params->{'detach'}) {
		print "Detaching.\n" unless ($params->{'quiet'});
		exit(0) if (fork());
		POSIX::setsid();
		exit(0) if (fork());
		close STDOUT;
		close STDERR;
		open (STDOUT, ">>output") or die ("Cannot open 'output' as STDOUT\n");
		open (STDERR, ">&STDOUT") or die ("Cannot dup STDOUT as STDERR\n");
		close STDIN;
		$redirected_stdio = 1;
		print "Startup at ".scalar localtime().".\n";
		daemon_run( $params->{'process'} );
		print "done at ".scalar localtime().".\n";
	} else {
		daemon_run( $params->{'process'} );
	};
} elsif ($COMMAND eq 'dumpconf') {
	Echolot::Config::dump();
} elsif ($COMMAND eq 'convert') {
	Echolot::Globals::initStorage();
	setSigHandlers();

	Echolot::Globals::get()->{'storage'}->convert();

	Echolot::Globals::get()->{'storage'}->commit();
	Echolot::Globals::get()->{'storage'}->finish();
} else {
	die ("Command $COMMAND unknown");
};

exit 0;

# vim: set ts=4 shiftwidth=4:
